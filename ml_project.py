# -*- coding: utf-8 -*-
"""ML Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W7j_pd7UtAZkBvDepT6E9QQ3uxnMSp3z

IMAGE CLASSIFICATION + SONG PLAYER
"""

pip install numpy opencv-python scikit-learn joblib playsound

# ===============================================================
# IMAGE CLASSIFICATION + SONG PLAYER
# ===============================================================

# ---------------------------------------------------------------
# 1. Imports and Configuration
# ---------------------------------------------------------------
import os
import cv2
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import joblib
from google.colab import files
from IPython.display import Audio, display
import time

CLASS1_DIR = "Folder1"   # Class 0: Triangles
CLASS2_DIR = "Folder2"   # Class 1: Circles
MODEL_PATH = "rf_image_model.pkl"
IMAGE_SIZE = (64, 64)
SONG_CLASS1 = ""
SONG_CLASS2 = ""

# ---------------------------------------------------------------
# 2. Setup and Data Upload
# ---------------------------------------------------------------

def setup_and_upload():
    """Handles folder creation and file uploads (images and songs)."""
    global SONG_CLASS1, SONG_CLASS2

    print("--- 1. UPLOADING TRAINING IMAGES ---")
    os.makedirs(CLASS1_DIR, exist_ok=True)
    os.makedirs(CLASS2_DIR, exist_ok=True)

    # Upload Class 0 (Triangle) Images
    print("Upload Triangle images for Folder1 (Class 0)")
    uploaded_triangle = files.upload()
    for name, data in uploaded_triangle.items():
        with open(os.path.join(CLASS1_DIR, name), "wb") as f:
            f.write(data)

    # Upload Class 1 (Circle) Images
    print("\nUpload Circle images for Folder2 (Class 1)")
    uploaded_circle = files.upload()
    for name, data in uploaded_circle.items():
        with open(os.path.join(CLASS2_DIR, name), "wb") as f:
            f.write(data)

    # Upload Songs
    print("\n--- 2. UPLOADING SONG FILES ---")

    print("Upload the song file for the Triangle class")
    uploaded_song1 = files.upload()
    SONG_CLASS1 = list(uploaded_song1.keys())[0]

    print("Upload the song file for the Circle class")
    uploaded_song2 = files.upload()
    SONG_CLASS2 = list(uploaded_song2.keys())[0]

# ---------------------------------------------------------------
# 3. Preprocessing and Dataset
# ---------------------------------------------------------------

def load_images_from_folder(folder, label):
    """Loads, preprocesses, and flattens images from a directory."""
    features, labels = [], []
    for fname in os.listdir(folder):
        fpath = os.path.join(folder, fname)
        if not os.path.isfile(fpath): continue

        img = cv2.imread(fpath, cv2.IMREAD_UNCHANGED)
        if img is None: continue

        if len(img.shape) == 3:
            img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        img_resized = cv2.resize(img, IMAGE_SIZE, interpolation=cv2.INTER_AREA)
        img_norm = img_resized.astype(np.float32) / 255.0

        features.append(img_norm.flatten())
        labels.append(label)
    return features, labels

def build_dataset():
    """Builds the full dataset (X=features, y=labels)."""
    f1, l1 = load_images_from_folder(CLASS1_DIR, 0)
    f2, l2 = load_images_from_folder(CLASS2_DIR, 1)

    X = np.array(f1 + f2)
    y = np.array(l1 + l2)
    return X, y

# ---------------------------------------------------------------
# 4. Model Training
# ---------------------------------------------------------------

def train_and_save_model(X, y):
    """Trains a RandomForestClassifier, evaluates, and saves."""
    print("\n--- 3. TRAINING MODEL ---")

    unique, counts = np.unique(y, return_counts=True)
    if len(unique) < 2:
        raise ValueError("Error: Training requires images for both classes.")

    stratify_option = y if np.min(counts) >= 2 else None

    X_train, X_val, y_train, y_val = train_test_split(
        X, y, test_size=0.3, random_state=42, stratify=stratify_option
    )

    clf = RandomForestClassifier(n_estimators=100, random_state=42)
    clf.fit(X_train, y_train)

    y_pred = clf.predict(X_val)
    accuracy = accuracy_score(y_val, y_pred)
    print(f"Training Complete. Validation Accuracy: {accuracy:.2f}")

    joblib.dump(clf, MODEL_PATH)
    print(f"Model saved to: {MODEL_PATH}")
    return clf

# ---------------------------------------------------------------
# 5. Prediction and Playback
# ---------------------------------------------------------------

def predict_and_play(test_file):
    """Predicts class of a test image and plays the corresponding song."""
    print("\n--- 4. PREDICTION AND PLAYBACK ---")

    clf = joblib.load(MODEL_PATH)

    img = cv2.imread(test_file, cv2.IMREAD_UNCHANGED)
    if img is None: raise ValueError(f"Error: Could not read test image: {test_file}")

    if len(img.shape) == 3: img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img_resized = cv2.resize(img, IMAGE_SIZE, interpolation=cv2.INTER_AREA)
    img_norm = img_resized.astype(np.float32) / 255.0
    feat = img_norm.flatten().reshape(1, -1)

    pred = clf.predict(feat)[0]

    if pred == 0:
        shape = "Triangle"
        song_path = SONG_CLASS1
    else:
        shape = "Circle"
        song_path = SONG_CLASS2

    print(f"Analyzing {os.path.basename(test_file)}...")
    time.sleep(1.5)
    print(f"Prediction: The shape is a **{shape}**.")

    display(Audio(song_path, autoplay=True))

# ---------------------------------------------------------------
# 6. Main Execution
# ---------------------------------------------------------------
if __name__ == "__main__":

    setup_and_upload()
    X, y = build_dataset()

    if len(X) > 0:
        model = train_and_save_model(X, y)

        print("\n--- 5. UPLOAD TEST IMAGE ---")
        print("Upload an image to test the model:")
        test_img = files.upload()

        if test_img:
            test_path = list(test_img.keys())[0]
            predict_and_play(test_path)

    else:
        print("\nExecution aborted: No images were loaded for training.")